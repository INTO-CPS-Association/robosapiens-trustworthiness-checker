use std::str::FromStr;
use std::collections::BTreeMap;
use ecow::{EcoString, EcoVec};

use crate::lang::dynamic_lola::ast::{SExpr, STopDecl, SBinOp, NumericalBinOp, CompBinOp, BoolBinOp, StrBinOp};
use crate::core::{Value, VarName, StreamType};

grammar;

// Tokens ////////////////////////////////////////////////////////////
match {
    r"\s*" => { }, // Ignore whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Ignore `// comments`
    r#"\(\*[^*]*\*+(?:[^\)*][^*]*\*+)*\)"# => { },  // Ignore `(* comments *)`
} else {
    _
}

Ident: VarName = <s:r"[a-z_]\w*"> => VarName::from(s);
Int: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Float: f64 = <s:r"(?:0|[1-9][0-9]*)\.[0-9]*(?:[eE]-?[0-9]+)?"> => f64::from_str(s).unwrap();
Bool: bool = {
    "true" => true,
    "false" => false
};
String: EcoString = <s:r#""[^\\"\n\r]*(?:\\[tn'"\\][^\\"\n\r]*)*""#> => s[1..s.len()-1].into();

// Macros ////////////////////////////////////////////////////////////
Box<T>: Box<T> = {
    <T> => Box::new(<>),
}

// A list of elements separated by Sep
SepList<T, Sep>: EcoVec<T> = {
    <mut v:(<T> Sep)*> <e:T> => {
        v.push(e);
        v.into()
    }
};

// An optional list of elements separated by Sep
SepListOpt<T, Sep>: EcoVec<T> = {
    SepList<T, Sep>,
    => EcoVec::new(),
};

// Key-value pair:
KVPair<K, V>: (K, V) = {
    <k: K> ":" <v: V> => (k, v)
};

// Expressions ///////////////////////////////////////////////////////

IdentSExpr : SExpr = {
    Ident => SExpr::Var(<>),
};

MultExprHelp: SBinOp  = {
    "*" => SBinOp::NOp(NumericalBinOp::Mul),
    "/" => SBinOp::NOp(NumericalBinOp::Div),
};

MultExpr<Next>: SExpr = {
    <lhs: Box<MultExpr<Next>>> <op: MultExprHelp> <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, op)
    },
    Next
};

AddExprHelp: SBinOp  = {
    "+" => SBinOp::NOp(NumericalBinOp::Add),
    "-" => SBinOp::NOp(NumericalBinOp::Sub),
};

AddExpr<Next>: SExpr = {
    <lhs: Box<AddExpr<Next>>> <op: AddExprHelp> <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, op)
    },
    Next
};

OrExpr<Next>: SExpr = {
    <lhs: Box<OrExpr<Next>>> "||" <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, SBinOp::BOp(BoolBinOp::Or))
    },
    Next
};

AndExpr<Next>: SExpr = {
    <lhs: Box<AndExpr<Next>>> "&&" <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, SBinOp::BOp(BoolBinOp::And))
    },
    Next
};

ConcatExpr<Next>: SExpr = {
    <lhs: Box<ConcatExpr<Next>>> "++" <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, SBinOp::SOp(StrBinOp::Concat))
    },
    Next
}

CompExprHelp: SBinOp = {
    "<=" => SBinOp::COp(CompBinOp::Le),
    "==" => SBinOp::COp(CompBinOp::Eq),
}

CompExpr<Next>: SExpr = {
    <lhs: Box<CompExpr<Next>>> <op: CompExprHelp> <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, op)
    },
    Next
};

SIndexHelp: Box<SExpr> = {
    Box<Literal>,
    Box<IdentSExpr>,
    Box<Paren>
};

SIndex: SExpr = {
    <expr: SIndexHelp> "[" <neg: "-"?> <idx: Int> "]" => {
        let i: isize = idx.try_into().unwrap();
        let i = if neg.is_some() { -i } else { i };
        SExpr::SIndex(expr, i)
    },
};

UnaryMinusHelper: SExpr = {
    <n: Int> => SExpr::Val(Value::Int(-n)),
    <n: Float> => SExpr::Val(Value::Float(-n)),
    <x: IdentSExpr> => SExpr::BinOp(Box::new(SExpr::Val(Value::Int(0))), Box::new(x), SBinOp::NOp(NumericalBinOp::Sub)),
    <x: Paren> => SExpr::BinOp(Box::new(SExpr::Val(Value::Int(0))), Box::new(x), SBinOp::NOp(NumericalBinOp::Sub)),
};

UnaryExpr<Next>: SExpr = {
    "-" <n: UnaryMinusHelper> => n,
    Next
};

ContainerExpr: SExpr = {
    "List" "(" <SepListOpt<Expr, ",">> ")" => SExpr::List(<>),
    "Map" "(" <kv_pairs: SepListOpt<KVPair<String, Expr>, ",">> ")" => SExpr::Map(BTreeMap::from_iter(kv_pairs.into_iter()))
}

LiteralVal: Value = {
    Int => Value::Int(<>),
    Float => Value::Float(<>),
    Bool => Value::Bool(<>),
    String => Value::Str(<>),
}

Literal: SExpr = {
    LiteralVal => SExpr::Val(<>),
};

Paren: SExpr = {
    "(" <Expr> ")"
};

Atom: SExpr = {
    SIndex,
    SpecialKeywords,
    Literal,
    ContainerExpr,
    IdentSExpr,
    Paren
}

Ifelse: SExpr = {
    "if" <c: Box<Expr>> "then" <i: Box<Expr>> "else" <e: Box<Expr>> => SExpr::If(c, i, e)
}

StreamTyp: StreamType = {
    "Int" => StreamType::Int,
    "Str" => StreamType::Str,
    "Float" => StreamType::Float,
    "Bool" => StreamType::Bool,
    "Unit" => StreamType::Unit,
}

TypeAnno: StreamType = {
    ":" <StreamTyp> => <>
}

SpecialKeywords: SExpr = {
    "dynamic" "(" <e: Box<Expr>> ")" => SExpr::Dynamic(e),
    "eval" "(" <e: Box<Expr>> ")" => SExpr::Dynamic(e),
    "defer" "(" <e: Box<Expr>> ")" => SExpr::Defer(e),
    "update" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::Update(e1, e2),
    "default" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::Default(e1, e2),
    "List.get" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::LIndex(e1, e2),
    "List.concat" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::LConcat(e1, e2),
    "List.append" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::LAppend(e1, e2),
    "List.head" "(" <e: Box<Expr>> ")" => SExpr::LHead(e),
    "List.tail" "(" <e: Box<Expr>> ")" => SExpr::LTail(e),
    "List.len" "(" <e: Box<Expr>> ")" => SExpr::LLen(e),
    "Map.get" "(" <e: Box<Expr>> "," <k: String> ")" => SExpr::MGet(e, k),
    "Map.remove" "(" <e: Box<Expr>> "," <k: String> ")" => SExpr::MRemove(e, k),
    "Map.has_key" "(" <e: Box<Expr>> "," <k: String> ")" => SExpr::MHasKey(e, k),
    "Map.insert" "(" <e1: Box<Expr>> "," <k: String> "," <e2: Box<Expr>> ")" => SExpr::MInsert(e1, k, e2),
}

// Operator precedence chain with Final having highest precedence
PrecChain<Final>: SExpr = {
    ConcatExpr<OrExpr<AndExpr<CompExpr<AddExpr<MultExpr<UnaryExpr<Final>>>>>>>,
}

pub Expr: SExpr = {
    Ifelse, // If-else binds weaker than the PrecChain chain to ensure that if a then b else c + d is parsed as if a then b else (c + d)
    PrecChain<Atom>
};

InputDecl: STopDecl = {
    "in" <id: Ident> <typ: TypeAnno?> => STopDecl::Input(id, typ)
};

OutputDecl: STopDecl = {
    "out" <id: Ident> <typ: TypeAnno?> => STopDecl::Output(id, typ),
};

AuxDecl: STopDecl = {
    "aux" <id: Ident> <typ: TypeAnno?> => STopDecl::Aux(id, typ),
    "var" <id: Ident> <typ: TypeAnno?> => STopDecl::Aux(id, typ),
};

Assignment: STopDecl = {
    <var: Ident> "=" <expr: Expr> => STopDecl::Assignment(var, expr)
}

pub TopDecl: STopDecl = {
    InputDecl,
    OutputDecl,
    AuxDecl,
    Assignment
}

pub TopDecls: EcoVec<STopDecl> = {
   TopDecl* => <>.into()
}
