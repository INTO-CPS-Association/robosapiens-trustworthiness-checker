use std::str::FromStr;
use std::collections::BTreeMap;
use ecow::{EcoString, EcoVec};

use crate::lang::dynamic_lola::ast::{SExpr, STopDecl, SBinOp, NumericalBinOp, CompBinOp, BoolBinOp, StrBinOp};
use crate::core::{Value, VarName, StreamType};

grammar;

// -----------------------------------------------------------------------------
// Tokens
// -----------------------------------------------------------------------------
match {
    r"\s*" => { }, // Ignore whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Ignore `// comments`
    r#"\(\*[^*]*\*+(?:[^\)*][^*]*\*+)*\)"# => { },  // Ignore `(* comments *)`
} else {
    _
}

Ident: VarName = <s:r"[A-Za-z_]\w*"> => VarName::from(s);
Uint: u64 = <s:r"[0-9]+"> => u64::from_str(s).unwrap();
// Negative numbers handled in unary minus - but need a separate case to not accept
// numbers too large for i64 here.
Int: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Float: f64 = <s:r"(?:0|[1-9][0-9]*)\.[0-9]*(?:[eE]-?[0-9]+)?"> => f64::from_str(s).unwrap();
Bool: bool = {
    "true" => true,
    "false" => false
};
String: EcoString = <s:r#""[^\\"\n\r]*(?:\\[tn'"\\][^\\"\n\r]*)*""#> => s[1..s.len()-1].into();

// -----------------------------------------------------------------------------
// Macros / generic helpers
// -----------------------------------------------------------------------------

// Box<T> helper
Box<T>: Box<T> = {
    <T> => Box::new(<>),
}

// A list of elements separated by Sep
SepList<T, Sep>: EcoVec<T> = {
    <mut v:(<T> Sep)*> <e:T> => {
        v.push(e);
        v.into()
    }
};

// An optional list of elements separated by Sep
SepListOpt<T, Sep>: EcoVec<T> = {
    SepList<T, Sep>,
    => EcoVec::new(),
};

// Key-value pair:
KVPair<K, V>: (K, V) = {
    <k: K> ":" <v: V> => (k, v)
};

// -----------------------------------------------------------------------------
// Terminals / simple expressions
// -----------------------------------------------------------------------------

// Literal values mapped to Value
LiteralVal: Value = {
    Int => Value::Int(<>),
    Float => Value::Float(<>),
    Bool => Value::Bool(<>),
    String => Value::Str(<>),
}

// Literal expression wrapper
Literal: SExpr = {
    LiteralVal => SExpr::Val(<>),
};

// Parenthesized expression
Paren: SExpr = {
    "(" <Expr> ")"
};

// Identifier as an SExpr (variable reference)
IdentSExpr : SExpr = {
    Ident => SExpr::Var(<>),
};

// Helpers for indexing base (literal, ident, or paren)
SIndexHelp: Box<SExpr> = {
    Box<Literal>,
    Box<IdentSExpr>,
    Box<Paren>
};

// Indexing expression e[idx]
SIndex: SExpr = {
    <expr: SIndexHelp> "[" <idx: Uint> "]" => {
        SExpr::SIndex(expr, idx)
    },
};

// Container constructors
ContainerExpr: SExpr = {
    "List" "(" <SepListOpt<Expr, ",">> ")" => SExpr::List(<>),
    "Map" "(" <kv_pairs: SepListOpt<KVPair<String, Expr>, ",">> ")" => SExpr::Map(BTreeMap::from_iter(kv_pairs.into_iter()))
}

// -----------------------------------------------------------------------------
// Special keywords / builtins (function-like forms)
// -----------------------------------------------------------------------------

SpecialKeywords: SExpr = {
    "dynamic" "(" <Box<Expr>> ")" => SExpr::Dynamic(<>),
    "eval" "(" <Box<Expr>> ")" => SExpr::Dynamic(<>),
    "defer" "(" <Box<Expr>> ")" => SExpr::Defer(<>),
    "update" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::Update(e1, e2),
    "default" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::Default(e1, e2),
    "is_defined" "(" <Box<Expr>> ")" => SExpr::IsDefined(<>),
    "when" "(" <Box<Expr>> ")" => SExpr::When(<>),
    "List.get" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::LIndex(e1, e2),
    "List.concat" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::LConcat(e1, e2),
    "List.append" "(" <e1: Box<Expr>> "," <e2: Box<Expr>> ")" => SExpr::LAppend(e1, e2),
    "List.head" "(" <Box<Expr>> ")" => SExpr::LHead(<>),
    "List.tail" "(" <Box<Expr>> ")" => SExpr::LTail(<>),
    "List.len" "(" <Box<Expr>> ")" => SExpr::LLen(<>),
    "Map.get" "(" <e: Box<Expr>> "," <k: String> ")" => SExpr::MGet(e, k),
    "Map.remove" "(" <e: Box<Expr>> "," <k: String> ")" => SExpr::MRemove(e, k),
    "Map.has_key" "(" <e: Box<Expr>> "," <k: String> ")" => SExpr::MHasKey(e, k),
    "Map.insert" "(" <e1: Box<Expr>> "," <k: String> "," <e2: Box<Expr>> ")" => SExpr::MInsert(e1, k, e2),
    "sin" "(" <Box<Expr>> ")" => SExpr::Sin(<>),
    "cos" "(" <Box<Expr>> ")" => SExpr::Cos(<>),
    "tan" "(" <Box<Expr>> ")" => SExpr::Tan(<>),
    "abs" "(" <Box<Expr>> ")" => SExpr::Abs(<>),
}

// -----------------------------------------------------------------------------
// Atom (base expressions with same precedence)
// -----------------------------------------------------------------------------

Atom: SExpr = {
    SIndex,
    SpecialKeywords,
    Literal,
    ContainerExpr,
    IdentSExpr,
    Paren
}

// -----------------------------------------------------------------------------
// Unary expressions
// -----------------------------------------------------------------------------

UnaryMinusHelper: SExpr = {
    <n: Int> => SExpr::Val(Value::Int(-n)),
    <n: Float> => SExpr::Val(Value::Float(-n)),
    <x: Box<IdentSExpr>> => SExpr::BinOp(Box::new(SExpr::Val(Value::Int(0))), x, SBinOp::NOp(NumericalBinOp::Sub)),
    <x: Box<Paren>> => SExpr::BinOp(Box::new(SExpr::Val(Value::Int(0))), x, SBinOp::NOp(NumericalBinOp::Sub)),
};

UnaryExpr<Next>: SExpr = {
    "-" <n: UnaryMinusHelper> => n,
    "!" <b: Box<UnaryExpr<Next>>> => SExpr::Not(b),
    Next
};

// -----------------------------------------------------------------------------
// Binary operators
// -----------------------------------------------------------------------------

// Multiplicative helpers
MultExprHelp: SBinOp  = {
    "*" => SBinOp::NOp(NumericalBinOp::Mul),
    "/" => SBinOp::NOp(NumericalBinOp::Div),
    "%" => SBinOp::NOp(NumericalBinOp::Mod),
};

MultExpr<Next>: SExpr = {
    <lhs: Box<MultExpr<Next>>> <op: MultExprHelp> <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, op)
    },
    Next
};

// Additive helpers
AddExprHelp: SBinOp  = {
    "+" => SBinOp::NOp(NumericalBinOp::Add),
    "-" => SBinOp::NOp(NumericalBinOp::Sub),
};

AddExpr<Next>: SExpr = {
    <lhs: Box<AddExpr<Next>>> <op: AddExprHelp> <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, op)
    },
    Next
};

// Relational operators ( < <= > >= )
RelExprHelp: SBinOp = {
    "<=" => SBinOp::COp(CompBinOp::Le),
    ">=" => SBinOp::COp(CompBinOp::Ge),
    "<" => SBinOp::COp(CompBinOp::Lt),
    ">" => SBinOp::COp(CompBinOp::Gt),
}

RelExpr<Next>: SExpr = {
    <lhs: Box<RelExpr<Next>>> <op: RelExprHelp> <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, op)
    },
    Next
};

// Comparison (==)
CompExprHelp: SBinOp = {
    "==" => SBinOp::COp(CompBinOp::Eq),
    // "!=" => SBinOp::COp(CompBinOp::Ne), // Not implemented yet
}

CompExpr<Next>: SExpr = {
    <lhs: Box<CompExpr<Next>>> <op: CompExprHelp> <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, op)
    },
    Next
};

// Boolean
AndExpr<Next>: SExpr = {
    <lhs: Box<AndExpr<Next>>> "&&" <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, SBinOp::BOp(BoolBinOp::And))
    },
    Next
};

OrExpr<Next>: SExpr = {
    <lhs: Box<OrExpr<Next>>> "||" <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, SBinOp::BOp(BoolBinOp::Or))
    },
    Next
};

// String concat
ConcatExpr<Next>: SExpr = {
    <lhs: Box<ConcatExpr<Next>>> "++" <rhs: Box<Next>> => {
        SExpr::BinOp(lhs, rhs, SBinOp::SOp(StrBinOp::Concat))
    },
    Next
}

// -----------------------------------------------------------------------------
// If-then-else (binds weaker than the precedence chain)
// -----------------------------------------------------------------------------

Ifelse: SExpr = {
    "if" <c: Box<Expr>> "then" <i: Box<Expr>> "else" <e: Box<Expr>> => SExpr::If(c, i, e)
}

// -----------------------------------------------------------------------------
// Types / annotations
// -----------------------------------------------------------------------------

StreamTyp: StreamType = {
    "Int" => StreamType::Int,
    "Str" => StreamType::Str,
    "Float" => StreamType::Float,
    "Bool" => StreamType::Bool,
    "Unit" => StreamType::Unit,
}

TypeAnno: StreamType = {
    ":" <StreamTyp> => <>
}

// -----------------------------------------------------------------------------
// Precedence chain: compose operator precedence from lowest â†’ highest
// -----------------------------------------------------------------------------

// Operator precedence chain with Final having highest precedence
PrecChain<Final>: SExpr = {
    ConcatExpr<OrExpr<AndExpr<CompExpr<RelExpr<AddExpr<MultExpr<UnaryExpr<Final>>>>>>>>,
}

// The top-level expression
pub Expr: SExpr = {
    Ifelse, // If-else binds weaker than the PrecChain chain to handle dangling else, i.e., if a then b else c + d is parsed as if a then b else (c + d)
    PrecChain<Atom>
};

// -----------------------------------------------------------------------------
// Top-level declarations
// -----------------------------------------------------------------------------

InputDecl: STopDecl = {
    "in" <id: Ident> <typ: TypeAnno?> => STopDecl::Input(id, typ)
};

OutputDecl: STopDecl = {
    "out" <id: Ident> <typ: TypeAnno?> => STopDecl::Output(id, typ),
};

AuxDecl: STopDecl = {
    "aux" <id: Ident> <typ: TypeAnno?> => STopDecl::Aux(id, typ),
    "var" <id: Ident> <typ: TypeAnno?> => STopDecl::Aux(id, typ),
};

Assignment: STopDecl = {
    <var: Ident> "=" <expr: Expr> => STopDecl::Assignment(var, expr)
}

pub TopDecl: STopDecl = {
    InputDecl,
    OutputDecl,
    AuxDecl,
    Assignment
}

pub TopDecls: EcoVec<STopDecl> = {
   TopDecl* => <>.into()
}
